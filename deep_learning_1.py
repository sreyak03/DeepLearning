# -*- coding: utf-8 -*-
"""DEEP LEARNING 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HCNoM_Vw_-0pNtzbVWnMxXhewW9vXKIc
"""

import numpy as np

class Perceptron:
  def __init__(self, input_size, learning_rate=0.1, epochs=100):
      self.weights = np.zeros(input_size)
      self.bias = 0
      self.learning_rate = learning_rate
      self.epochs = epochs
#This part of the perceptron class defines the constructor(__init__method),which initialize the key perceptron model.

  def activation(self,x):
    return 1 if x >= 0 else 0 #step function
#defining activation function

  def predict(self, x):
    z = np.dot(self.weights, x) + self.bias
    return self.activation(z)

  def train(self,X,y):
    for epoch in range(self.epochs):
      updates = 0 #Track updates to check convergence
      for i in range(len(X)):
        prediction = self.predict(X[i])
        error = y[i] - prediction
        if error != 0:
          self.weights += self.learning_rate * error * X[i]
          self.bias += self.learning_rate * error
          updates += 1

      if updates == 0:#if no updates, training is complete
        print(f"Converged at epoch",epoch+1)
        break

#the train method is responsible for training the perceptron model using labeled inputdata.
#it follows the perceptron learning algorithm, adjusting weights iteratively based on classification errors.

#example usage
X = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])#input features
y = np.array([0, 0, 0, 1]) #AND gate labels

perceptron = Perceptron(input_size=2)
perceptron.train(X, y)

#testing

for x in X:
  print(f"input:",x, " Predicted Output: ",perceptron.predict(x))

import numpy as np
import pandas as pd
url = "https://gist.githubusercontent.com/curran/a08a1080b88344b0c8a7/raw/0e7a9b0a5d22642a06d3d5b9bcbad9890c8ee534/iris.csv"
df=pd.read_csv(url)
df.head()

import pandas as pd

# Step 1: Load the dataset
file_path = "/content/iris.csv"  # Update with your actual file path
df = pd.read_csv(file_path)

# Step 2: Display unique species in the dataset
print("Unique species in dataset:", df['species'].unique())

# Step 3: Filter the dataset for only two species: 'setosa' and 'versicolor'
binary_df = df[df['species'].isin(['setosa', 'versicolor'])].copy()

# Step 4: Convert species column to binary values (setosa = 0, versicolor = 1)
binary_df['species'] = binary_df['species'].map({'setosa': 0, 'versicolor': 1})

# Step 5: Save the new dataset
binary_file_path = "iris_binary.csv"
binary_df.to_csv(binary_file_path, index=False)

print(f"Binary dataset saved to {binary_file_path}")

# Read the binary dataset you just saved
binary_df = pd.read_csv("iris_binary.csv")

# Display the first few rows to check the dataset
print(binary_df.head())

import numpy as np
import pandas as pd

class Perceptron:
    def __init__(self, input_size, learning_rate=0.1, epoch=100): # Changed _init_ to __init__
        self.weights = np.zeros(input_size)
        self.bias = 0
        self.learning_rate = learning_rate
        self.epoch = epoch

    def activation(self, x):
        return 1 if x >= 0 else 0  # Step function

    def predict(self, x):
        z = np.dot(self.weights, x) + self.bias
        return self.activation(z)

    def train(self, X, y):
        for epoch in range(self.epoch):
            updates = 0
            for i in range(len(X)):
                prediction = self.predict(X[i])
                error = y[i] - prediction
                if error != 0:
                    self.weights += self.learning_rate * error * X[i]
                    self.bias += self.learning_rate * error
                    updates += 1
            if updates == 0:
                print("Converged at epoch", epoch + 1)
                break

# Load dataset
file_path = "/content/iris.csv"
df = pd.read_csv(file_path)

# Convert categorical target variable to binary (Setosa = 1, Others = 0)
df['species'] = df['species'].apply(lambda x: 1 if x == 'setosa' else 0)

# Extract features and labels
X = df[['sepal_length', 'sepal_width', 'petal_length', 'petal_width']].values
y = df['species'].values

# Train perceptron
perceptron = Perceptron(input_size=4)
perceptron.train(X, y)

# Testing
for x in X[:5]:  # Display predictions for first 5 samples
    print("Input:", x, 'Predicted Output:', perceptron.predict(x))

import numpy as np
import pandas as pd
import requests
from io import StringIO

url = "https://gist.githubusercontent.com/netj/8836201/raw/iris.csv"
response = requests.get(url)
data = StringIO(response.text)

df = pd.read_csv(data)

X = df.iloc[:, :-1].values  # First 4 columns (features)
y = df.iloc[:, -1].values   # Last column (labels)

y = np.where(y == "Iris-setosa", 0, 1)

class Perceptron:
    def __init__(self, input_size, learning_rate=0.1, epochs=100): # Corrected _init_ to __init__
        self.weights = np.zeros(input_size)
        self.bias = 0
        self.learning_rate = learning_rate
        self.epochs = epochs

    def activation(self, x):
        return 1 if x >= 0 else 0

    def predict(self, x):
        z = np.dot(self.weights, x) + self.bias
        return self.activation(z)

    def train(self, x, y):
        for epoch in range(self.epochs):
            updates = 0
            for i in range(len(x)):
                prediction = self.predict(x[i])
                error = y[i] - prediction
                if error != 0:
                    self.weights += self.learning_rate * error * x[i]
                    self.bias += self.learning_rate * error
                    updates += 1
            if updates == 0:
                print(f'Converged at epoch {epoch+1}')
                break

perceptron = Perceptron(input_size=X.shape[1])
perceptron.train(X, y)

for i in range(10):
    print(f'Input: {X[i]}, Predicted Output: {perceptron.predict(X[i])}, Actual: {y[i]}')

import numpy as np
import pandas as pd


url = "https://gist.githubusercontent.com/netj/8836201/raw/6f9306ad21398ea43cba4f7d537619d0e07d5ae3/iris.csv"
df = pd.read_csv(url)


df['class'] = df['variety'].apply(lambda x: 1 if x == "Setosa" else 0)
df = df.drop(columns=['variety'])


X = df.iloc[:, :-1].values
y = df['class'].values


class Perceptron:
    def __init__(self, input_size, lr=0.1, epochs=100): # Corrected _init_ to __init__
        self.weights = np.zeros(input_size)
        self.bias = 0
        self.lr = lr
        self.epochs = epochs

    def activation(self, x):
        return 1 if x >= 0 else 0

    def predict(self, x):
        return self.activation(np.dot(self.weights, x) + self.bias)

    def train(self, X, y):
        for _ in range(self.epochs):
            for xi, target in zip(X, y):
                update = self.lr * (target - self.predict(xi))
                self.weights += update * xi
                self.bias += update


perceptron = Perceptron(input_size=X.shape[1])
perceptron.train(X, y)

for xi, target in zip(X, y):
    print(f"Input: {xi}, Predicted: {perceptron.predict(xi)}, Actual: {target}")